#! /usr/bin/env python

import logging

from . import (
    comex,
    data,
    errors,
    evaluator,
    metadata as csdlxml,
    model as csdl,
    names,
    parser,
    primitive,
    query,
    types,
    )
from ..py2 import (
    is_text,
    to_text,
    )
from ..rfc2396 import (
    escape_data,
    unescape_data,
    URI,
    )
from ..unicode5 import ParserError


class DataService(object):

    """Represents a Data service

    The service is the object used to make requests using the protocol
    documented in OData Part 1.  The OData specification binds the
    protocol to HTTP to make a RESTful web service but this class
    represents only the abstract protocol allowing it to be bound to a
    wider range of data services.  Concrete implementations are provided
    for mapping the service to HTTP (as per the specification) and
    SQL-based database servers.

    In most cases you won't need to call the DataService methods
    directly as the objects defined by the model will make the
    appropriate calls to read and write data as they are used.  You can
    discover the exposed entity sets through the :attr:`container` and
    use them directly to initiate requests.  The exceptions to this are
    when you want to use advanced features of the protocol such as batch
    requests or asynchronous execution."""

    def __init__(self):
        #: the entity model exposed by this service
        self.model = None
        #: the entity container exposed by this service
        self.container = None
        self.conventional_ids = True
        """Whether or not entity IDs are formed conventionally

        A value of True means that we will calculate entity IDs by
        appending key-predicates to entity set names.  Strictly speaking
        this setting should default to False as the specification states:

            Services are strongly encouraged to use the canonical URL
            for an entity as defined in OData-URL as its entity-id, but
            clients cannot assume...

        Oh but we do assume I'm afraid!  It goes on...

            Services that use the standard URL conventions for
            entity-ids annotate their entity container with the term
            Core.ConventionalIDs

        In our defence, the word MUST is not used (*cannot* is merely
        guidance) so we don't treat this as a requirement.  Services
        don't seem to use this annotation in practice, despite following
        the conventions, but if they do provide an annotation value we
        abide by it."""
        self.dereferenceable_ids = True
        """Whether or not entity IDs can be used as read/edit URLs

        A value of True means that we will use entity ids directly as if
        they were edit (or read) URLs.  An explicitly defined edit/read
        URL in the payload will still override this behaviour but if
        we've calculated an ID for an entity without ever having
        received it from the service (see :attr:`conventional_ids`) then
        we are as good as saying that entity IDs, read and edit URLs are
        all identical and calculable from the entity set name and key
        value.

        We default to True as most services do following the URL
        conventions even though the following clause suggests that False
        would be the correct default:

            clients cannot assume the entity-id can be used to locate
            the entity unless the Core.DereferenceableIDs term is
            applied to the entity container

        Again, we honour the annotation's value if it is present.  A
        value of False means we will use the $entity service end-point
        to retrieve entities passing the entity ID in the $id query
        parameter instead of just using the ID as the entity's URL
        directly"""
        #: the metadata document URL (the base for all contexts)
        self.context_base = None
        self._service_canonical_root = ""
        self._service_root_path = []
        #: the URL of the service root *as a character string*
        self.service_root = "/"
        self._entity_url = None
        #: the metadata document associated with this service, a
        #: :class:`metadata.CSDLDocument` instance.
        self.metadata = None
        #: a DataService instance that allows the protocol to be used to
        #: query to this service's entity model
        self.metadata_service = None
        #: the type of entity references *generated by this service*
        self.ref_type_def = None

    def set_context_base(self, url):
        """Sets the context_base URL for this service

        url
            A :class:`pyslet.rfc2396.URI` instance representing the
            context base for this service, i.e., the URL of the
            $metadata document.

        This method also sets the :attr:`service_root` attribute."""
        self.context_base = url
        # calculate the service root information
        self._service_canonical_root = url.get_canonical_root()
        path = url.abs_path.split("/")
        self._service_root_path = [
            # ignore the leading / and the trailing $metadata
            unescape_data(p).decode('utf-8') for p in path[1:-1]]
        r = list(escape_data(p.encode('utf-8'))
                 for p in self._service_root_path)
        r.insert(0, str(self._service_canonical_root))
        r.append("")
        self.service_root = "/".join(r)

    def set_container(self, container):
        self.container = container
        # look for interesting annotations
        tag = self.container.annotations.qualified_get(
            "Org.OData.Core.V1.DereferenceableIDs")
        if tag:
            self.dereferenceable_ids = csdl.Evaluator.evaluate_annotation(
                tag, container).get_value()
        tag = self.container.annotations.qualified_get(
            "Org.OData.Core.V1.ConventionalIDs")
        if tag:
            # we have a tag with a non-null value
            self.conventional_ids = csdl.Evaluator.evaluate_annotation(
                tag, container).get_value()

    def root_url(self):
        """Creates an OData URL representing the service root"""
        return ODataURL(self)

    def url_from_str(self, src):
        """Creates an OData URL from a character string

        src
            A character string representing the *encoded* URL."""
        try:
            split = src.index(":")
        except ValueError:
            raise errors.URLError("Service root must end in '/' (%s)" % src)
        scheme = src[:split]
        rest = src[split + 1:]
        split = rest.find("?")
        if split < 0:
            # no query
            query = ""
            split = rest.find("#")
            if split < 0:
                # no fragment
                fragment = ""
                hpart = rest
            else:
                hpart = rest[:split]
                fragment = rest[split + 1:]

        else:
            hpart = rest[:split]
            rest = rest[split + 1:]
            split = rest.find("#")
            if split < 0:
                fragment = ""
                query = rest
            else:
                query = rest[:split]
                fragment = rest[split + 1:]
        if hpart.startswith("//"):
            # authority is present
            path = hpart[2:].split("/")
            if len(path) < 2:
                raise errors.URLError(
                    "Service root must end in '/' (%s)" % src)
            authority = "//" + path[0]
        else:
            authority = ""
            path = hpart.split("/")
            if len(path) < 2:
                raise errors.URLError(
                    "Service root must end in '/' (%s)" % src)
        canonical_root = URI.from_octets(
            scheme + ':' + authority).get_canonical_root()
        if self._service_canonical_root and \
                self._service_canonical_root != canonical_root:
            raise errors.URLError("URL path is not in service canonical root")
        path = [unescape_data(p).decode('utf-8') for p in path[1:]]
        if self._service_root_path:
            i = 0
            while i < len(self._service_root_path):
                if i >= len(path) or self._service_root_path[i] != path[i]:
                    raise errors.URLError("URL path is not in service root")
                i += 1
            path = path[len(self._service_root_path):]
        url = ODataURL(self)
        url.set_resource_path(path)
        url.set_fragment(fragment)
        # second stage, split the query
        if query:
            options = query.split('&')
            for nv in options:
                split = nv.find('=')
                if split < 0:
                    name = nv
                    value = ""
                else:
                    name = nv[:split]
                    value = nv[split + 1:]
                url.set_query_option(
                    unescape_data(name).decode('utf-8'),
                    unescape_data(value).decode('utf-8'))
        return url

    def resolve_type(self, type_url):
        """Resolves an odata.type URL to a type definition

        type_url
            An :class:`pyslet.rfc2396.URI` instance containing the
            URL of the type."""
        # express this relative to our context
        if type_url.fragment:
            # if this is a simple identifier we have a built-in
            # primitive type
            if names.NameTable.is_simple_identifier(type_url.fragment):
                # ignore the actual URL
                return self.model["Edm"].get(type_url.fragment, None)
            else:
                qname, collection = csdlxml.type_name_from_str(
                    type_url.fragment)
                type_context = str(type_url).split('#')[0]
                if type_context == self.context_base:
                    type_def = self.model.qualified_get(qname)
                    if collection:
                        return types.CollectionType(type_def)
                    else:
                        return type_def
                else:
                    raise NotImplemented("Cross-service type references")
        else:
            raise errors.ServiceError("Invalid odata.type: %s" % str(type_url))

    def open(self, name):
        """Opens an item advertised by this service

        The return type depends on the type of the item being exposed.
        For an EntitySet the return type is an
        :class:`data.EntitySetValue` object, for a Singleton the return
        type is a :class:`model.SingletonValue`.

        The returned objects are bound to this service and all data
        access operations are performed using the methods defined by the
        service.

        This method is shorthand for::

            self.container[name]()"""
        return self.container[name]()

    def get_entity_collection(self, entity_set, next_link=None):
        """Creates a request for a collection of entities

        entity_set
            An EntitySetValue object bound to this service.

        next_link
            An optional *opaque* object passed to the loading method of
            the entity set during a previous execution. This value
            indicates that the previous execution returned only partial
            results and that the next chunk of results is being
            requested.

            For the OData client this is just the URL returned in the
            odata.nextLink annotation."""
        raise NotImplementedError

    def get_singleton(self, singleton):
        """Creates a request for an entity singleton

        singleton
            An SingletonValue object bound to this service."""
        raise NotImplementedError

    def get_entity_by_key(self, entity_set, key):
        """Creates a request to get an entity by key

        entity_set
            An EntitySetValue object bound to this service.  This can be
            an entity set exposed by the service in the container or an
            entity collection obtained through navigation.

        key
            The key of the desired entity.  The key is used to look up
            the entity in the entity set.

        Returns a :class:`DataRequest` instance.  When executed, the
        result of of the request is an entity object or an appropriate
        exception."""
        raise NotImplementedError

    def indexable_by_key(self, entity_set):
        """Determines whether or not an entity set is indexable by key

        entity_set
            An EntitySetValue object bound to this service.  This can be
            an entity set exposed by the service in the container or an
            entity collection obtained through navigation.

        The entity_set value must be bound to an EntitySet in the
        container to be indexable, we also check the
        Org.OData.Capabilities.V1.IndexableByKey annotation of that
        EntitySet.  If this annotation has not been applied, the usual
        case, then we return True despite encouragement in the
        specification to return False.  In practice, this annotation is
        not widely used despite (almost?) all services exposing
        indexable entity sets."""
        binding = entity_set.entity_binding
        if binding is not None:
            result = True
            a = binding.annotations.qualified_get(
                "Org.OData.Capabilities.V1.IndexableByKey")
            if a is not None:
                result = evaluator.Evaluator.evaluate_annotation(
                    a, binding).get_value()
            if result is not False:
                result = True
        else:
            result = False
        return result

    def get_collection(self, collection, next_link=None):
        """Creates a request to get a general collection

        collection
            A CollectionValue object bound to this service

        next_link
            An optional *opaque* object passed to the loading method of
            the collection during a previous execution.  This value
            indicates that the previous execution returned only partial
            results and that the next chunk of results is being
            requested."""
        raise NotImplementedError

    def get_item_count(self, collection):
        """Creates a request for the number of items in a collection

        collection
            A CollectionValue object bound to this service"""
        raise NotImplementedError

    def get_property(self, pvalue):
        """Creates a request for an individual property

        pvalue
            A primitive or complex property value

        Returns a :class:`DataRequest` instance.  When executed, the
        property value is updated by reloading the value from the
        service."""
        raise NotImplementedError

    def create_entity(self, entity_collection, entity, omit_clean=False):
        """Create a request to create an entity in a collection

        entity_collection
            An :class:`data.EntitySetValue` or a collection of
            entities.

        Returns a :class:`DataRequest` instance.  When executed, the
        entity is updated from the service to include any computed
        values."""
        raise NotImplementedError

    def get_entity(self, entity):
        """Creates a request to retrieve an existing entity

        entity
            An entity value object previously returned by the service.

        The entity is reloaded (according to any select/expand options
        already specifed on creation).

        Returns a :class:`DataRequest` instance.  When executed, the
        result of the request is *entity* updated with the current
        values of the requested properties."""
        raise NotImplementedError

    def update_entity(self, entity, merge=True):
        """Create a request to update an entity

        entity
            An :class:`data.EntityValue`.

        merge
            Whether or not to use merge semantics (PATCH).  Defaults to
            True, in this mode only properties marked as dirty are sent
            to the service and the PATCH method is used, otherwise all
            properties are sent to the server and the PUT method is used.

        Returns a :class:`DataRequest` instance.  If executed
        successfully all updated values are marked as clean."""
        raise NotImplementedError

    def delete_entity_by_key(self, entity_set, key):
        """Deletes an entity from an entity set

        entity_set
            An EntitySetValue object bound to this service.  This can be
            an entity set exposed by the service in the container or an
            entity collection obtained through navigation.

        key
            The key of the entity to delete.

        Returns a :class:`DataRequest` instance.  There is no return
        result.  If the entity set does not contain an entity with *key*
        then a :class:`errors.ServiceError` is raised with code 404.

        The behaviour of this request depending on the entity set.  If
        the entity set represents a collection-valued navigation
        property that does *not* contain the related entities then the
        effect is to remove the relationship between two entities.  On
        the other hand, if the entity set represents an entity set
        exposed in the service document or a collection-valued
        navigation property that *contains* the related entities then
        the effect is to delete the entity with *key* outright."""
        raise NotImplementedError

    def delete_entity(self, entity):
        """Create a request to delete an entity

        entity
            An :class:`data.EntityValue`.

        Returns a :class:`DataRequest` instance.  There is no return
        result.  Unlike :meth:`delete_entity_by_key` this method always
        deletes the entity from the entity set that *contains* it, even
        if the *entity* value was obtained from non-containment
        navigation property.  This form of deletion is required for
        entities that use optimistic concurrency control on deletion as
        the entity must be retrieved (with the associated ETag) before
        it can be deleted."""
        raise NotImplementedError

    def call_function(self, function):
        """Creates a request for a function call

        function
            A :class:`CallableValue` object representing a function call.

        Returns a :class:`DataRequest` instance.  When executed, the
        result of of the request is a :class:`Value` object of the
        appropriate return type or an appropriate exception."""
        raise NotImplementedError

    def call_action(self, action):
        """Creates a request for an action call

        action
            A :class:`CallableValue` object representing an action call.

        Returns a :class:`DataRequest` instance.  When executed, the
        result of of the request is a :class:`Value` object of the
        appropriate return type or an appropriate exception."""
        raise NotImplementedError

    def get_entity_id(self, entity):
        """Returns the ID (an entity reference) for an entity

        A transient entity will return None, otherwise a string is
        returned representing the entity reference.  If the entity is
        not transient but has not been bound to this service (yet) then
        it is bound by this method before the ID is returned.

        If the reference cannot be determined then
        :class:`errors.InvalidEntityID` exception will be raised meaning
        the entity is neither known to be transient nor has an odata.id.
        Sadly this can happen, one option is to fix this using
        :meth:`fix_entity_id` if the parent entity set is known or can
        be guessed."""
        id = entity.get_annotation("@odata.id")
        if id is not None:
            if id.is_null():
                # transient entity!
                return None
            if id.value:
                # entity with a known id
                if entity.service is None:
                    # bind it to this service
                    entity.bind_to_service(self)
                return id.value
            # an empty string is not acceptable here
        if entity.entity_binding:
            # if there is no id then we must have all the key fields
            # AND the url is just the canonical url of the entity
            # set or singleton
            url = self.url_from_str(
                to_text(entity.entity_binding.get_url()))
            if isinstance(entity.entity_binding, csdl.EntitySet):
                # for entity sets only, add the key
                key = entity.type_def.get_key_dict(entity.get_key())
                url.add_key_predicate(key)
            if entity.service is None:
                entity.bind_to_service(self)
            return to_text(url)
        # if we are a named property of a parent then we are a contained
        # singleton, the id is obtained from the parent
        if entity.parent:
            url = self.get_value_url(entity.parent())
            url.add_path_segment(entity.name)
            id = to_text(url)
            # fix up the missing odata.id attribute
            term = self.model.qualified_get("odata.id")
            odata_id = entity.get_updatable_annotation(term)
            odata_id.set_value(id)
            if entity.service is None:
                entity.bind_to_service(self)
            return id
        # otherwise we're swimming in a collection with no id
        raise errors.InvalidEntityID

    def fix_entity_id(self, entity, parent):
        """Fixes the ID of the entity based on a parent object

        The parent object must be a value with a resolvable location (e.g.,
        a navigation property of an entity in a bound entity set).  The
        id of the entity is calculated by adding a key-predicate to the
        parent's location, effectively binding the entity on the fly.

        On success, the odata.id annotation of the entity is updated to
        reflect the new binding and the entity is bound to this service
        if it is not already bound."""
        url = self.get_value_url(parent)
        if isinstance(parent, (data.EntitySetValue, data.CollectionValue)):
            # we need to add the key
            key = entity.type_def.get_key_dict(entity.get_key())
            url.add_key_predicate(key)
        id = to_text(url)
        term = self.model.qualified_get("odata.id")
        odata_id = entity.get_updatable_annotation(term)
        logging.warning("Fixing missing ID for entity %s" % id)
        odata_id.set_value(id)
        if entity.service is None:
            entity.bind_to_service(self)

    def get_value_url(self, value, edit=False):
        """Calculates the read or edit link of a value

        We follow the guidance in Part 1; 4.2 when determining the link
        for a property of an entity.  For entity sets we use the URLs
        returned in the service document.  For entities we follow the
        annotation conventions in JSON 4.5.8; other payload types ensure
        they generate the appropriate annotations during
        deserialization."""
        url = None
        if value.parent is not None:
            # this is a named property of an entity or structured type
            path = []
            entity = value.get_entity(path)
            if entity is None:
                raise errors.UnboundValue
            url = self.get_value_url(entity, edit=edit)
            for seg in path:
                url.add_path_segment(seg)
        elif isinstance(value, data.EntityContainerValue) and \
                value.entity_binding:
            # this is just an entity set or singleton read/edit url in
            # service doc
            url = self.url_from_str(
                to_text(value.entity_binding.get_url()))
        elif isinstance(value, data.EntityValue):
            if not edit:
                # check for an explicit readLink
                read_link = value.get_annotation("@odata.readLink")
                if read_link:
                    url = self.url_from_str(
                        to_text(read_link.value.get_value()))
            if not url:
                edit_link = value.get_annotation("@odata.editLink")
                if edit_link:
                    url = self.url_from_str(
                        to_text(edit_link.value.get_value()))
            if not url:
                # default is the entity-id with a cast if required
                id = value.get_annotation("@odata.id")
                if id is not None:
                    if id.is_null():
                        # transient entity!
                        raise errors.ServiceError(
                            "Can't read or edit a transient entity")
                    url = self.url_from_str(
                        to_text(id.get_value()))
                    if (value.entity_binding and
                            value.entity_binding.entity_type is not
                            value.type_def):
                        url.add_path_segment(value.type_def.qname)
            if not url and value.entity_binding:
                # if there is no id then we must have all the key fields
                # AND the url is just the canonical url of the entity
                # set or singleton
                url = self.url_from_str(
                    to_text(value.entity_binding.get_url()))
                if isinstance(value.entity_binding, csdl.EntitySet):
                    # for entity sets only, add the key
                    key = value.type_def.get_key_dict(value.get_key())
                    url.add_key_predicate(key)
            if not url:
                raise errors.ODataError("Can't read or edit unbound entity")
        else:
            raise errors.ODataError("Can't calculate target URL")
        return url

    # TBC below

    def get_entity_by_ref(self, entity_ref, type_cast=None, options=None):
        """Creates a request to retrieve an existing entity

        entity_ref
            An :class:`model.EntityRefValue` object previously returned
            by the service.

        type_cast
            An optional :class:`model.EntityType` object to act as a
            type cast filter to determine the type of object to return.

        options
            An optional :class:`query.EntityOptions` object.

        Returns a :class:`DataRequest` instance.  When executed, the
        result of the request is an :class:`data.EntityValue` or an
        appropriate :class:`errors.ServiceError` instance."""
        raise NotImplementedError

    def get_entity_ref_by_key(self, entity_set_value, key):
        """Creates a request to get the reference to an existing entity.

        Similear to :meth:`get_entity_by_key` except that, when
        executed, the resulting request returns a
        :class:`model.EntityRefValue` instance instead of the entity
        itself. As a result there are no additional options."""
        raise NotImplementedError

    def get_entity_media(self, entity):
        """Creates a request to an entity's media stream

        entity
            An entity object previously returned by the service. The
            entity must be of a type that has a media stream.

        Returns a :class:`DataRequest` instance."""
        raise NotImplementedError

    def get_property_value(self, entity, path):
        """Creates a request for an individual property value

        entity
            The entity object that contains the property

        path
            The path to the property being requested as an iterable
            list of strings.

        Returns a :class:`DataRequest` instance.  When executed, the
        result is the appropriate Python 'native' object as described in
        the model.  This value is also used to update the property of
        the original entity instance."""
        raise NotImplementedError

    def upsert_entity(self, entity, merge=True):
        #: entity may not exist
        raise NotImplementedError

    def add_entity_ref(self, entity_collection, entity):
        raise NotImplementedError

    def remove_entity_ref(self, entity_collection, entity):
        raise NotImplementedError

    def set_entity_ref(self, entity_ref):
        raise NotImplementedError

    def delete_entity_ref(self, entity_ref):
        raise NotImplementedError

    def create_media_entity(self, entity_collection, sinfo, s):
        raise NotImplementedError

    def update_media_entity_stream(self, entity, sinfo, s):
        raise NotImplementedError

    # delete_media_entity is the same as delete_entity

    def update_stream_property(self, entity, path, sinfo, s):
        raise NotImplementedError

    def delete_stream_property(self, entity, path):
        raise NotImplementedError

    def update_property(self, entity, path, value):
        raise NotImplementedError

    def update_property_value(self, entity, path, value):
        raise NotImplementedError

    def delete_property(self, entity, path):
        raise NotImplementedError

    def update_complex_property(self, entity, path, value, merge=True):
        raise NotImplementedError

    def new_batch(self):
        """Creates a new batch request"""
        raise NotImplementedError

    def new_change_set(self):
        """Creates a new changeset request"""
        raise NotImplementedError

    # concurrency: match: etag or any; no-match: etag or any
    # isolation: snapshots?


class DataRequest(object):

    """Represents a request to the Data service

    This is an abstract class.  Concrete implementations of a data
    service will use their own derived classes to bind each request to a
    particular protocol.  For example, the OData client extends this
    class to hold information about the HTTP message that will be sent
    to the server when the request is executed.

    You create DataRequest instances using the appropriate method of the
    DataService."""

    def __init__(self, service, target):
        #: the service that created this request
        self.service = service
        #: the target of the request
        self.target = target
        #: the result of the request (type is request specific).  If the
        #: the request failed the result will be an instance of
        #: :class:`ServiceError`
        self.result = None
        #: if the result is a partial result then next_request is a data
        #: service request suitable for retrieving the next part of the
        #: result
        self.next_request = None
        #: optional custom parameters
        self.params = {}

    def set_params(self, params=None):
        """Adds custom parameters to this request"""
        if params is not None:
            raise NotImplementedError

    def execute_request(self, track_changes=None, callback=None):
        """Executes a previously created request"""
        raise NotImplementedError

    def terminate_request(self):
        """Cancels a request previously executed aynchronously (i.e.,
        using a callback)."""
        raise NotImplementedError


class ChangeSet(DataRequest):

    """Represents a change set

    A change set is a group of DataRequest instances that will be
    invoked as an atomic group."""
    pass


class BatchRequest(DataRequest):

    """Represents a batch

    A batch is a group of DataRequest instances that will be invoked
    as a group."""
    pass


class RequestExpired(errors.ServiceError):

    """Raised when a request that has expired is executed"""

    def __init__(self, message=None):
        super(errors.ServiceError, self).__init__(message, 410, "Gone")


class EntityNotFound(errors.ServiceError):

    """Raised when the requested entity does not exist or is null"""

    def __init__(self, message=None):
        super(errors.ServiceError, self).__init__(message, 404, "Not Found")


class NotAMediaStream(errors.ServiceError):

    """Raised when the requested entity is not a media stream but the
    request requires one."""

    def __init__(self, message=None):
        super(errors.ServiceError, self).__init__(message, 400, "Bad Request")


class PropertyNotAvailable(errors.ServiceError):

    """Raised when the requested property value is not available, for
    example due to permissions."""

    def __init__(self, message=None):
        super(errors.ServiceError, self).__init__(message, 404, "Not Found")


class ResourcePathSegment(object):

    """Object representing a single resource path segment

    There are two attributes.  The name attribute contains one of a
    string (containing a simple identifier or $special name) or a
    :class:`csdl.QualifiedName` instance.

    The params attribute contains a dictionary that maps strings (simple
    identifier parameter names) on to :class:`csdl.Value` instances or
    strings representing parameter aliases (starting '@').  In the
    special case of a key with a single property value the empty string
    is used as the dictionary key."""

    def __init__(self):
        self.name = None
        self.params = {}


class ODataURL(object):

    """Represents an OData URL"""

    def __init__(self, service):
        #: the service this URL refers to
        self.service = service
        #: the resource path, an array of decoded text strings
        self.resource_path = []
        #: the resource path as an array of ResourcePathSegment instances
        self.resource_path_segments = []
        #: the query options, a dictionary mapping text -> text strings
        self.query_options = {}
        #: the property options represented in the query
        self.sys_query_options = query.SystemQueryOptions()
        #: the fragment
        self.fragment = None

    def __str__(self):
        url = self.service.service_root + "/".join(
            escape_data(p) for p in self.resource_path)
        if self.query_options:
            url = url + "?" + "&".join(
                escape_data(n) + "=" + escape_data(v)
                for n, v in self.query_options.items())
        if self.fragment:
            url = url + '#' + self.fragment
        return url

    def set_resource_path(self, path):
        """Set the resource path from a list

        The list elements are either decoded character strings
        representing the individual segments *or* they are
        :class:`ResourcePathSegment` instances representing interpreted
        path segments."""
        self.resource_path = []
        self.resource_path_segments = []
        for seg in path:
            self.add_path_segment(seg)

    def add_path_segment(self, segment):
        """Adds a resource path segment

        segment
            Either a decoded character string *or* a
            :class:`ResourcePathSegment` instance representing an
            interpreted path segment."""
        if isinstance(segment, ResourcePathSegment):
            seg_str = str(segment)
            seg_obj = segment
        else:
            try:
                seg_obj = self.path_segment_from_str(segment)
            except ParserError as err:
                raise errors.URLError(to_text(err))
            seg_str = segment
        self.resource_path.append(seg_str)
        self.resource_path_segments.append(seg_obj)

    def add_key_predicate(self, key_dict):
        """Adds a key predicate to the last segment in the resource path"""
        index = len(self.resource_path_segments) - 1
        seg = self.resource_path_segments[index]
        if seg.params:
            raise errors.URLError("URL already has a key or params")
        seg.params = key_dict
        # update the formatted version of this segment
        if len(key_dict) > 1:
            kp_str = "(%s)" % ",".join(
                "%s=%s" % (n, v.literal_string()) for n, v in key_dict.items())
        else:
            kp_str = "(%s)" % next(iter(key_dict.values())).literal_string()
        self.resource_path[index] += kp_str

    def add_inline_params(self, params):
        """Adds a set of inline params to the resource path"""
        index = len(self.resource_path_segments) - 1
        seg = self.resource_path_segments[index]
        if seg.params:
            raise errors.URLError("URL already has key or params")
        seg.params = params
        # update the formatted version of this segment
        if len(params) > 1:
            p_str = "(%s)" % ",".join(
                "%s=%s" % (n, v.literal_string()) for n, v in params.items())
        else:
            p_str = "()"
        self.resource_path[index] += p_str

    def set_query_option(self, name, value):
        """Set a query option from a name/value pair (as decoded strings)"""
        if name == '$select':
            p = parser.Parser(value)
            select = p.require_select()
            p.require_end()
            self.sys_query_options.select = select
        elif name == '$filter':
            p = parser.Parser(value)
            filter = p.require_filter()
            p.require_end()
            self.sys_query_options.filter = filter
        elif name == '$expand':
            p = parser.Parser(value)
            expand = p.require_expand()
            p.require_end()
            self.sys_query_options.expand = expand
        self.query_options[name] = value

    def set_expand(self, expand):
        """Set the expand system query option

        expand
            A list of :class:`query.ExpandItem`."""
        self.sys_query_options.clear_expand()
        if expand:
            for item in expand:
                self.sys_query_options.add_expand_item(item)
            self.query_options['$expand'] = ",".join(
                to_text(i) for i in expand)
        else:
            try:
                del self.query_options['$expand']
            except KeyError:
                pass

    def set_select(self, select):
        """Set the select system query option

        select
            A list of SelectItem instances."""
        self.sys_query_options.clear_select()
        if select:
            for item in select:
                self.sys_query_options.add_select_item(item)
            self.query_options['$select'] = ",".join(
                to_text(i) for i in select)
        else:
            try:
                del self.query_options['$select']
            except KeyError:
                pass

    def add_filter(self, filter):
        """Adds a filter to the query options

        filter
            A :class:`CommonExpresison` instance.

        The value is stored in the :attr:`sys_query_options` *and*
        converted to a string and stored in the query_options
        dictionary."""
        self.sys_query_options.set_filter(filter)
        if filter is None:
            self.query_options.pop('$filter', None)
        else:
            # convert a filter expression to a string, can only
            # be done through a special form of evaluation
            self.query_options['$filter'] = self.expr_to_str(filter)

    def add_orderby(self, orderby):
        """Adds an orderby clause to the query options

        orderby
            An iterable of :class:`query.OrderbyItem` instances.

        The value is stored in the :attr:`sys_query_options` *and*
        converted to a string and stored in the query_options
        dictionary."""
        self.sys_query_options.set_orderby(orderby)
        if not orderby:
            self.query_options.pop('$orderby', None)
        else:
            self.query_options['$orderby'] = self.orderby_to_str(orderby)

    @staticmethod
    def orderby_to_str(orderby):
        result = []
        for item in orderby:
            item_str = ODataURL.expr_to_str(item.expr)
            if item.direction > 0:
                item_str += " asc"
            elif item.direction < 0:
                item_str += " desc"
            result.append(item_str)
        return ",".join(result)

    def add_top(self, top):
        """Adds top to the query options

        top
            An integer (or None)"""
        self.sys_query_options.set_top(top)
        if top is None:
            self.query_options.pop('$top', None)
        else:
            self.query_options['$top'] = to_text(top)

    def add_skip(self, skip):
        """Adds skip to the query options

        skip
            An integer (or None)"""
        self.sys_query_options.set_skip(skip)
        if skip is None:
            self.query_options.pop('$skip', None)
        else:
            self.query_options['$skip'] = to_text(skip)

    @staticmethod
    def expr_to_str(expr):
        return comex.ExpressionFormatter().evaluate(expr)[1]
        if isinstance(expr, comex.CallExpression):
            # binds strongly so is never bracketed but arguments are
            # bracketed and don't need further bracketing even though
            # they are weaker than us
            return expr.format_expr(
                [ODataURL.expr_to_str(op) for op in expr.operands])
        elif isinstance(expr, comex.OperatorExpression):
            ops = []
            for op in expr.operands:
                op_str = ODataURL.expr_to_str(op)
                if op < expr:
                    # add brackets, child operator is weaker, e.g.,
                    # expr = E1 * 3
                    # E1 = 2 + 2, E1 formats as "2 add 2"
                    # expr formats as (2 add 2) mul 3
                    op_str = "(%s)" % op_str
                ops.append(op_str)
            return expr.format_expr(ops)
        elif isinstance(expr, comex.LiteralExpression):
            if isinstance(expr.value, names.EnumLiteral):
                return to_text(expr.value)
            else:
                return primitive.PrimitiveValue.from_value(
                    expr.value).literal_string()
        elif isinstance(expr, comex.IdentifierExpression):
            return expr.identifier
        elif isinstance(expr, comex.WordExpression):
            # not allowed in a normal expression
            raise errors.ODataError("Unexpected WordExpression")
        else:
            raise errors.ODataError(
                "Unexpected expression node: %s" % repr(expr))

    def add_search(self, search):
        """Adds a search to the query options

        search
            A :class:`CommonExpression` instance

        The value is stored in the :attr:`sys_query_options` *and*
        converted to a string and stored in the query_options
        diectionary."""
        self.sys_query_options.set_search(search)
        if search is None:
            self.query_options.pop('$search', None)
        else:
            self.query_options['$search'] = search.search_text()

    def set_fragment(self, fragment):
        """Set the fragment from an *encoded* character string"""
        self.fragment = fragment

    def path_segment_from_str(self, segment):
        """Returns a decoded resource path segment

        index
            Integer index of the path segment

        Returns a :class:`ResourcePathSegment` instance."""
        result = ResourcePathSegment()
        p = parser.Parser(segment)
        if p.parse("$"):
            # special name
            result.name = "$" + p.require_odata_identifier()
            p.require_end()
            return result
        result.name = p.parse_production(p.require_qualified_name)
        if result.name is None:
            result.name = p.require_odata_identifier()
        if p.parse("("):
            # parse the parameters
            while True:
                # start with name=value
                save_pos = p.pos
                pname = p.parse_production(p.require_odata_identifier)
                if pname and p.parse("="):
                    if p.parse("@"):
                        pvalue = "@" + p.require_odata_identifier()
                    else:
                        pvalue = p.require_primitive_literal()
                    result.params[pname] = pvalue
                    if not p.parse(","):
                        break
                else:
                    # a primitive_literal may look like a key or
                    # function parameter name, e.g., key property
                    # stupidly named "null" or "inf"
                    p.setpos(save_pos)
                    pvalue = p.require_primitive_literal()
                    result.params[""] = pvalue
                    break
            p.require(")")
            p.require_end()
        return result

    def set_id(self, id):
        """Set the id system query option"""
        if id is None:
            self.sys_query_options.set_id(None)
            self.query_options.pop('$id', None)
        else:
            if not is_text(id):
                id = to_text(id)
            self.sys_query_options.set_id(id)
            self.query_options['$id'] = id
